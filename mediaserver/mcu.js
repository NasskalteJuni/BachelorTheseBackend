// like any 'normal' web client, handle connections with a connection-manager object.
// just pass in the (autogenerated) signaller, which wraps the Tunnel-Objects methods in Websocket-like methods
const iceServers = [];
const signaler = MediaUtilities.wrapTunnelAsSignaler(Tunnel);
const connections = new MediaUtilities.ConnectionManager({name: '@mcu', signaler, isYielding: true, verbose: true, iceServers});
const videoMixer = new MediaUtilities.VideoMixer({width: 640, height: 480});
const speechDetection = new MediaUtilities.SpeechDetection();
const audioMixers = {};
videoMixer.addConfig(new MediaUtilities.VideoMixingConfigurations.Speaker(speechDetection), 'Speaker');
let isActive = false; // IMPORTANT! IF YOU START WITH AN MCU ARCHITECTURE, THIS MUST BE SET TO TRUE (obviously)

Tunnel.onImport('iceServers', ice => {
    console.log('switching ice servers from', iceServers, 'to', ice);
    iceServers.splice(0, iceServers.length);
    ice.forEach(s => iceServers.push(s));
});


// listen for received streams, then, forward the received streams to everyone else
connections.addEventListener('streamadded', (stream, user) => {
    console.log('stream added for', user, stream);
    videoMixer.addMedia(stream, user);
    speechDetection.addMedia(stream, user);
    Object.keys(audioMixers).filter(key => user !== key).forEach(key => audioMixers[key].addMedia(stream,user));
});
// when a stream ends / is removed, stop forwarding it
connections.addEventListener('streamremoved', (stream, user) => {
    console.log('stream removed for', user, stream);
    videoMixer.removeMedia(user);
    speechDetection.removeMedia(user);
    Object.keys(audioMixers).filter(key => user !== key).forEach(key => audioMixers[key].removeMedia(user));
});
// every user has his own audio mixer
connections.addEventListener('userconnected', (user) => {
    audioMixers[user] = new MediaUtilities.AudioMixer();
    if(isActive) connections.get(user).addMedia(new MediaStream([audioMixers[user].outputTrack, videoMixer.outputTrack]));
});
// which will be removed when the user disconnects
connections.addEventListener('userdisconnected', (user) => {
    delete audioMixers[user];
    Object.values(audioMixers).forEach(audioMixer => audioMixer.removeMedia(user));
    videoMixer.removeMedia(user);
    speechDetection.removeMedia(user);
});
signaler.addEventListener('message', message => {
    if(message.type === "architecture:switch" && message.sender === "@server"){
        if(message.data === "mcu" && !isActive){
	    console.log("starting up mcu media processing");
	    isActive = true;
            connections.users.forEach(user => {
                connections.get(user).addMedia(new MediaStream([audioMixers[user].outputTrack, videoMixer.outputTrack]));
            });
        }else if(message.data !== "mcu" && isActive){
	    console.log("stopping the mcu media processing");
	    isActive = false;
            connections.users.forEach(user => {
                connections.get(user).removeMedia();
            });
        }
    }else if(message.type && message.type.startsWith("user:")){
	if(message.type === "user:connected"){
	    console.log("user joined", message.data);
	}else if(message.type === "user:disconnected"){
	    console.log("user left", message.data);
	}
    }
});